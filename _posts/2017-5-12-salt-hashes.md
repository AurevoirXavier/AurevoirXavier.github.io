---
layout: post
title: "salt your hashes"
date:   2017-05-12
excerpt: "盐化你的哈希 (为你的哈希加盐)"
tags: [Cryotology]
comments: true
---

<center><h2>盐化你的哈希 (为你的哈希加盐)</h2></center>

<!--more-->

### 哈希

哈希是单向函数，它产生一个通常是数字的数据。它们总是从相同的数据生成相同的*散列*，并没有简单的方法来反转进程。这使得它们对密码存储非常有用。不过不是存储用户的密码，而是存储密码的哈希值。当用户再次登录时，不是检查与存储的密码相对应的密码，而是计算输入密码的哈希值，并将其与存储的哈希进行比较。有很多不同的哈希算法，最常用的是 **MD5** 和 **SHA1**。

### 哈希安全吗

也许你很容易就认为只需要简单地执行一遍加密哈希函数，密码就能安全，那么你大错特错了。有太多的办法可以快速地把密码从简单哈希值中恢复出来，但也有很多比较容易实现的技术能使攻击者的效率大大降低。黑客的进步也在激励着这些技术的进步，比如这样一个[网站](http://cmd5.com/)：你可以提交一系列待破解的哈希值，并且在不到 1 秒的时间内得到了结果。显然，简单哈希加密并不能满足我们对安全性的需求。不幸的是，确保密码安全存储并不像使用存储密码的哈希一样简单。散列的两个优势也是他们最大的潜在弱点：它们很小，可以存储和快速生成。例如，为了生成英文中每个单词的 **SHA1** 和 **MD5** *散列*，都需要时间。要存储的数据量也是微不足道的。要生成字母和数字的所有组合的哈希值，加上几个常用的标点符号，最多可以说 8 个字符，但是没有任何特殊的设置或设备，仍然可行。这样的数据的预先计算的*散列表*可以很容易地在线发现或容易地生成。如果有一些数据的哈希 (如密码)，并且想要查看最初的数据，则可以将哈希值与预先计算的表中的条目进行比较。如果找到匹配项，已经发现最初用于生成哈希的数据。因此，基本的密码散列对于大多数用户来说基本上是无用的。将基本密码的哈希与预先计算的散列表进行比较从而大大减少 *“dehash” 密码*这一工作,是一个简单的过程。有些人推荐嵌套哈希值作为增加复杂性并因此增加安全性的方法。不幸的是，生成嵌套哈希表几乎与简单的哈希一样容易，而且安全性差不多。

### 如何破解哈希

**字典攻击和暴力攻击**

- 破解哈希加密最简单的办法，就是去猜，将每个猜测值哈希之后的结果和目标值比对，如果相同则破解成功。两种最常见的猜密码的办法是**字典攻击**和**暴力攻击**。
- 字典攻击需要使用一个字典文件，它包含单词、短语、常用密码以及其他可能用作密码的字符串。其中每个词都是进过哈希后储存的，用它们和密码哈希比对，如果相同，这个词就是密码。字典文件的构成是从大段文本中分解出的单词，甚至还包括一些数据库中真实的密码。然后还可以对字典文件进行更进一步的处理使它更有效，比如把单词中的字母替换为它们的 “形近字” (hello 变为 h3110)。
- 暴力攻击会尝试每一个在给定长度下各种字符的组合。这种攻击会消耗大量的计算，也通常是破解哈希加密中效率最低的办法，但是它最终会找到正确的密码。因此密码需要足够长，以至于遍历所有可能的字符串组合将耗费太长时间，从而不值得去破解它。
- 我们没有办法阻止字典攻击和暴击攻击，尽管可以降低它们的效率，但那也不是完全阻止。如果你的密码哈希系统足够安全，唯一的破解办法就是进行字典攻击或者暴力遍历每一个哈希值。

**查表法**

- 查表法对于破解一系列算法相同的哈希值有着无与伦比的效率。主要的思想就是**预计算**密码字典中的每个密码，然后把哈希值和对应的密码储存到一个用于快速查询的数据结构中。一个良好的查表实现可以每秒进行数百次哈希查询，即使表中储存了几十亿个哈希值。

**反向查表法**

- 这种方法可以使攻击者同时对多个哈希值发起字典攻击或暴力攻击，而不需要预先计算出一个查询表。
- 首先攻击者构造一个基于密码 - 用户名的一对多的表，当然数据需要从某个已经被入侵的数据库获得，然后猜测一系列哈希值并且从表中查找拥有此密码的用户。通常许多用户可能有着相同的密码，因此这种攻击方式也显得尤为有效。

**彩虹表**

- 彩虹表是一种在时间和空间的消耗上找寻平衡的破解技术。它和查表法很类似，但是为了使查询表占用的空间更小而牺牲了破解速度。因为它更小，于是我们可以在一定的空间内存储更多的哈希值，从而使攻击更加有效。能够破解任何 8 位及以下长度 **MD5** 值的[彩虹表](http://www.freerainbowtables.com/en/tables2/)已经出现了。

### 盐化 (加盐)

解决方案是将哈希不仅仅是用户的密码，而这个过程叫做 **“salting (盐化)”**。查表法和彩虹表只有在所有密码都以相同方式进行哈希加密时才有效。如果两个用户密码相同，那么他们密码的哈希值也是相同的。我们可以通过 “随机化” 哈希来阻止这类攻击，于是当相同的密码被哈希两次之后，得到的值就不相同了。比如可以在密码中混入一段 “随机” 的字符串再进行哈希加密，这个被字符串被称作盐值。为了校验密码是否正确，我们需要储存盐值。通常和密码哈希值一起存放在账户数据库中，或者直接存为哈希字符串的一部分。盐值并不需要保密，由于随机化了哈希值，查表法、反向查表法和彩虹表都不再有效。攻击者无法确知盐值，于是就不能预先计算出一个查询表或者彩虹表。这样每个用户的密码都混入不同的盐值后再进行哈希，因此反向查表法也变得难以实施。例如，可以将邮箱地址及其密码的哈希存储在一起，而不是存储用户密码的散列。这是有效的，因为生成数据超过约 10 个字符的散列表的难度开始变得刁钻 (因为随机添加了一段额外的字符串) 以生成和存储。在这一点上，表格必须基于词典和已知的单词生成，而不是生成一个范围内所有可能的密码的编程列表。“电子邮件加密码” 的平均长度容易在 25 个字符的区域内。不仅如此，如果有人制定出正在使用 “电子邮件加密码” 的散列表，那么他们仍然需要为每个要排除的密码生成一个新的表格。这种复杂性水平加上相当强大的密码策略，确保如果 (或何时) 用户数据被暴露出来，从其中提取可用密码所涉及的工作量将会让人望而却步，除非这个攻击者有着坚定不移的决心。不仅如此，即使他们发现，数据的批量提取也是非常困难的。

### 盐化过程中注意事项：

**避免短盐值和盐值重复**

- **盐值重复**：每次哈希加密都使用相同的盐值是很容易犯的一个错误，这个盐值要么被硬编码到程序里，要么只在第一次使用时随机获得。这样加盐的方式是做无用功，因为两个相同的密码依然会得到相同的哈希值。攻击者仍然可以使用反向查表法对每个值进行字典攻击，只需要把盐值应用到每个猜测的密码上再进行哈希即可。如果盐值被硬编码到某个流行的软件里，可以专门为这个软件制作查询表和彩虹表，那么破解它生成的哈希值就变得很简单了。用户创建账户或每次修改密码时，都应该重新生成新的盐值进行加密。
- **短盐值**：如果盐值太短，攻击者可以构造一个查询表包含所有可能的盐值。以只有 3 个 ASCII 字符的盐值为例，一共有 95x95x95 = 857,375 种可能。这看起来很多，但是如果对于每个盐值查询表只包含 1 MB 最常见的密码，那么总共只需要837GB的储存空间。一个不到 100$ 的 1000 GB 硬盘就能解决问题。同样地，用户名也不应该被用作盐值。尽管在一个网站中用户名是唯一的，但是它们是可预测的，并且经常重复用于其他服务中。攻击者可以针对常见用户名构建查询表，然后对用户名盐值哈希发起进攻。为了使攻击者无法构造包含所有可能盐值的查询表，盐值必须足够长。一个好的做法是使用和哈希函数输出的字符串等长的盐值，比如 SHA256 算法的输出是 256bits (32 bytes)，那么盐值也至少应该是 32 个随机字节。

**避免两次哈希和组合哈希函数**：

- 使用组合哈希函数。人们经常不由自主地认为将不同的哈希函数组合起来，结果会更加安全。实际上这样做几乎没有好处，仅仅造成了函数之间互相影响的问题，甚至有时候会变得更加不安全。永远不要尝试发明自己的加密方法，只需只用已经被设计好的标准算法。有的人会说使用多种哈希函数会使计算更慢，从而破解也更慢，但是还有其他的办法能更好地减缓破解速度，后面会提到的。

<center>这里有些低端的组合哈希函数 (不要使用其中任何一种)：</center>

- md5(sha1(password))

- md5(md5(salt) + md5(password))

- sha1(sha1(password))

- sha1(str_rot13(password + salt))

- md5(sha1(md5(md5(password) + sha1(password)) + md5(password)))

有许多抗议者，为组合哈希函数而辩护。他们的理由是如果攻击者不知道系统使用的哪种哈希函数，那么也就很难预先为这种组合构造出彩虹表，于是破解起来会花费更多的时间。诚然，攻击者在不知道加密算法的时候是无法发动攻击的，但是不要忘了 [Kerckhoffs’s principle](https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle)，攻击者通常很容易就能拿到源码 (尤其是那些免费或开源的软件)。通过系统中取出的一些密码-哈希值对应关系，很容易反向推导出加密算法。破解组合哈希函数确实需要更多时间，但也只是受了一点可以确知的因素影响。更好的办法是使用一个很难被并行计算出结果的迭代算法，然后增加适当的盐值防止彩虹表攻击。

**应该**使用：

- OpenWall 的 [Portable PHP password hashing framework](http://www.openwall.com/phpass/)
- 任何先进的、被良好测试过的哈希加密算法，比如 `SHA256，SHA512，RipeMD，WHIRLPOOL，SHA3` 等等
- 设计良好的密钥扩展算法，如 [PBKDF2](http://en.wikipedia.org/wiki/PBKDF2)，[bcrypt](http://en.wikipedia.org/wiki/Bcrypt)，[scrypt](http://www.tarsnap.com/scrypt.html)
- 安全的 `crypt()` 版本 `(\$2y\$，\$5\$，\$6\$)`

**不要**使用：

- **过时**的函数，比如MD5或SHA1
- **不**安全的 `crypt()` 版本 `(\$1\$，\$2\$，\$2x\$，\$3\$)`
- 任何你自己设计的加密算法。只应该使用那些在公开领域中的，并且被密码学家完整测试过的技术

### 进阶

**基本要素：加盐哈希**

- 盐值应该使用**基于加密的伪随机数生成器 (Cryptographically Secure Pseudo-Random Number Generator – CSPRNG)** 来生成。*CSPRNG* 和普通的随机数生成器有很大不同，如 C 语言中的 `rand()` 函数。物如其名，*CSPRNG* 专门被设计成用于加密，它能提供高度随机和无法预测的随机数。我们显然不希望自己的盐值被猜测到，所以一定要使用 *CSPRNG*。

<center>当前主流编程语言中的 *CSPRNG* 方法：</center>

<center>
|||
| :------: | :--------------------------------: |
|PHP | [mcrypt_create_iv](http://php.net/manual/en/function.mcrypt-create-iv.php), [openssl_random_pseudo_bytes](http://php.net/manual/en/function.openssl-random-pseudo-bytes.php)  |
|               Java                | [java.security.SecureRandom](http://docs.oracle.com/javase/6/docs/api/java/security/SecureRandom.html) |
|         Dot NET (C#, VB)          | [System.Security.Cryptography.RNGCryptoServiceProvider](http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider.aspx) |
|               Ruby                | [SecureRandom](http://rubydoc.info/stdlib/securerandom/1.9.3/SecureRandom) |
|              Python               | [os.urandom](http://docs.python.org/library/os.html) |
  |               Perl                | [Math::Random::Secure](http://search.cpan.org/~mkanat/Math-Random-Secure-0.06/lib/Math/Random/Secure.pm) |
  |        C/C++ (Windows API)        | [CryptGenRandom](http://en.wikipedia.org/wiki/CryptGenRandom) |
  | Any language on GNU/Linux or Unix | Read from [/dev/random or /dev/urandom](http://en.wikipedia.org/wiki/dev/random) |
</center>


- 对于每个用户的每个密码，盐值都应该是独一无二的。每当有新用户注册或者修改密码，都应该使用新的盐值进行加密。并且这个盐值也应该足够长，使得有足够多的盐值以供加密。一个好的标准的是：盐值至少和哈希函数的输出一样长；盐值应该被储存和密码哈希一起储存在账户数据表中。

**在 *Web 程序*中，永远在服务器端进行哈希加密**

- 如果你正在开发一个 *Web 程序*，你可能会疑惑到底在哪进行加密。是使用 JavaScript 在用户的浏览器上操作呢，还是将密码 “赤裸裸” 的传送到服务器再进行加密？即使浏览器端用 JavaScript 加密了，你仍然需要在服务端再次进行加密。试想有个网站在浏览器将密码经过哈希后传送到服务器，那么在认证用户的时候，网站收到哈希值和数据库中的值进行比对就可以了。这看起来比只在服务器端加密安全得多，因为至始至终没有将用户的密码明文传输，但实际上不是这样。问题在于，从客户端来看，经过哈希的密码逻辑上成为用户真正的密码。为了通过服务器认证，用户只需要发送密码的哈希值即可。如果有攻击者获取了这个哈希值，他甚至可以在不知道用户密码的情况通过认证。更进一步，如果他用某种手段入侵了网站的数据库，那么不需要去猜解任何人的密码，就可以随意使用每个人的帐号登录。这并不是说你不应该在浏览器端进行加密，但是如果你这么做了，一定要在服务端再次加密。在浏览器中进行哈希加密是个好想法，不过实现的时候注意下面几点：

1. 客户端密码哈希并**不能代替** *HTTPS (SSL/TLS)*。如果浏览器和服务器之间的连接是不安全的，那么中间人攻击可以修改 JavaScript 代码，删除加密函数，从而获取用户密码。
2. 有些浏览器不支持 JavaScript，也有的用户禁用了浏览器的 JavaScript 功能。为了最好的兼容性，你的程序应该检测 JavaScript 是否可用，如果答案为否，需要在服务端模拟客户端的加密。
3. 客户端哈希同样需要加盐，很显然的办法就是向服务器请求用户的盐值，但是不要这么做。因为这给了攻击者一个机会，能够在不知道密码的情况下检测用户名是否有效。既然你已经在服务端对密码进行了加盐哈希，那么在客户端把用户名 (或邮箱) 加上网站特有的字符串 (如域名) 作为盐值是可行的。

**让密码更难破解：慢哈希函数**

- 加盐使攻击者无法采用特定的查询表和彩虹表快速破解大量哈希值，但是却不能阻止他们使用字典攻击或暴力攻击。高端的显卡 (GPU) 和定制的硬件可以每秒进行数十亿次哈希计算，因此这类攻击依然可以很高效。为了降低攻击者的效率，我们可以使用一种叫做**密钥扩展**的技术。这种技术的思想就是把哈希函数变得很慢，于是即使有着超高性能的GPU或定制硬件，字典攻击和暴力攻击也会慢得让攻击者无法接受。最终的目标是把哈希函数的速度降到足以让攻击者望而却步，但造成的延迟又不至于引起用户的注意。密钥扩展的实现是依靠一种 CPU 密集型哈希函数。不要尝试自己发明简单的迭代哈希加密，如果迭代不够多，是可以被高效的硬件快速并行计算出来的，就和普通哈希一样。应该使用标准的算法，比如 [PBKDF2](http://en.wikipedia.org/wiki/PBKDF2) 或者 [bcrypt](http://en.wikipedia.org/wiki/Bcrypt)。[这里](https://defuse.ca/php-pbkdf2.htm) 可以找到 *PBKDF2* 在 PHP 上的一种实现。这类算法使用一个安全因子或迭代次数作为参数，这个值决定了哈希函数会有多慢。对于桌面软件或者手机软件，获取参数最好的办法就是执行一个简短的性能基准测试，找到使哈希函数大约耗费0.5秒的值。这样，你的程序就可以尽可能保证安全，而又不影响到用户体验。
- 如果你在一个 *Web程序*中使用密钥扩展，记得你需要额外的资源处理大量认证请求，并且密钥扩展也使得网站更容易遭受拒绝服务攻击 (DoS)。但我依然推荐使用密钥扩展，不过把迭代次数设定得低一点，你应该基于认证请求最高峰时的剩余硬件资源来计算迭代次数。要求用户每次登录时输入验证码可以消除拒绝服务的威胁。另外，一定要把你的系统设计为迭代次数可随时调整的。
- 如果你担心计算量带来的负载，但又想在 *Web程序*中使用密钥扩展，可以考虑在浏览器中用 JavaScript 完成。[Stanford JavaScript Crypto Library](http://crypto.stanford.edu/sjcl/)里包含了 *PBKDF2* 的实现。迭代次数应该被设置到足够低，以适应速度较慢的客户端，比如移动设备。同时当客户端不支持 *JavaScript* 的时候，服务端应该接手计算。客户端的密钥扩展并不能免除服务端进行哈希加密的职责，你必须对客户端传来的哈希值再次进行哈希加密，就像对付一个普通密码一样。

**无法破解的哈希加密：密钥哈希和密码哈希设备**

- 只要攻击者可以检测对一个密码的猜测是否正确，那么他们就可以进行字典攻击或暴力攻击。因此下一步就是向哈希计算中增加一个**密钥**，只有知道这个密钥的人才能校验密码。有两种办法可以实现：将哈希值加密，比如使用 **AES** 算法；将密钥包含到哈希字符串中，比如使用密钥哈希算法 [HMAC](http://en.wikipedia.org/wiki/HMAC)。听起来很简单，做起来就不一样了。这个密钥需要在任何情况下都不被攻击者获取，即使系统因为漏洞被攻破了。如果攻击者获取了进入系统的最高权限，那么不论密钥被储存在哪，他们都可以窃取到。因此密钥需要储存在外部系统中，比如另一个用于密码校验的物理服务器，或者一个关联到服务器的特制硬件，如 [YubiHSM](https://www.yubico.com/YubiHSM)。我强烈推荐大型服务(10 万用户以上) 使用这类办法，因为我认为面对如此多的用户是有必要的。
- 如果你难以负担多个服务器或专用的硬件，仍然有办法在一个普通 Web 服务器上利用密钥哈希技术。大部分针对数据库的入侵都是由于 [SQL注入攻击](http://en.wikipedia.org/wiki/SQL_injection)，因此不要给攻击者进入本地文件系统的权限 (禁止数据库服务访问本地文件系统，如果它有这个功能的话)。这样一来，当你随机生成一个密钥存到通过 *Web 程序*无法访问的文件中，然后混入加盐哈希，得到的哈希值就不再那么脆弱了，即便这时数据库遭受了注入攻击。不要把将密钥硬编码到代码里，应该在安装时随机生成。这当然不如独立的硬件系统安全，因为如果 *Web 程序*存在 *SQL 注入点*，那么可能还存在其他一些问题，比如本地文件包含漏洞 (Local File Inclusion)，攻击者可以利用它读取本地密钥文件。无论如何，这个措施比没有好。
- 请注意密钥哈希不代表无需进行加盐。高明的攻击者迟早会找到办法窃取密钥，因此依然对密码哈希进行加盐和密钥扩展很重要。

**其他安全措施**

- 哈希加密可以在系统发生入侵时保护密码，但这并不能使整个程序更加安全。首先还有很多事情需要做，来保证密码哈希 (和其他用户数据) 不被窃取。
- 即使经验丰富的开发者也需要额外学习安全知识，才能写出安全的程序。这里有个关于 *Web 程序*漏洞的资源：[The Open Web Application Security Project (OWASP)](https://www.owasp.org/index.php/Main_Page)，还有一个很好的介绍：[OWASP Top Ten Vulnerability List](http://owasptop10.googlecode.com/files/OWASP%20Top%2010%20-%202013.pdf)。除非你了解列表中所有的漏洞，才能尝试编写一个处理敏感数据的 *Web程序*。雇主也有责任保证他所有的开发人员都有资质编写安全的程序。
- 对你的程序进行第三方 “渗透测试” 是一个不错的选择。最好的程序员也可能犯错，因此有一个安全专家审查你的代码寻找潜在的漏洞是有意义的。找寻值得信赖的机构 (或招聘人员) 来对你的代码进行审查。安全审查应该从编码的初期就着手进行，一直贯穿整个开发过程。
- 监控你的网站来发现入侵行为也是很重要的，我推荐至少雇佣一个人全职负责监测和处理安全隐患。如果有个漏洞没被发现，攻击者可能通过网站利用恶意软件感染访问者，因此检测漏洞并且及时应对是十分重要的。